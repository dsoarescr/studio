import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import PixelGrid from '@/components/pixel-grid/PixelGrid';
import { useUserStore, usePixelStore } from '@/lib/store';

// Mock the stores
jest.mock('@/lib/store', () => ({
  useUserStore: jest.fn(),
  usePixelStore: jest.fn(),
}));

// Mock the AI function - temporarily disabled
// jest.mock('@/ai/flows/generate-pixel-description', () => ({
//   generatePixelDescription: jest.fn().mockResolvedValue({
//     description: 'This is a test description generated by AI.'
//   }),
// }));

describe('PixelGrid Component', () => {
  beforeEach(() => {
    // Setup default mock implementations
    (useUserStore as jest.Mock).mockReturnValue({
      addCredits: jest.fn(),
      addXp: jest.fn(),
      addPixel: jest.fn(),
    });
    
    (usePixelStore as jest.Mock).mockReturnValue({
      soldPixels: [],
      addSoldPixel: jest.fn(),
      updatePixelColor: jest.fn(),
      loadSoldPixels: jest.fn().mockReturnValue([]),
    });
    
    // Mock canvas methods
    HTMLCanvasElement.prototype.getContext = jest.fn(() => ({
      clearRect: jest.fn(),
      fillRect: jest.fn(),
      drawImage: jest.fn(),
      getImageData: jest.fn(() => ({
        data: new Uint8ClampedArray(4),
      })),
      putImageData: jest.fn(),
      save: jest.fn(),
      restore: jest.fn(),
      translate: jest.fn(),
      scale: jest.fn(),
      stroke: jest.fn(),
      strokeRect: jest.fn(),
    }));
  });
  
  it('renders loading state initially', () => {
    render(<PixelGrid />);
    expect(screen.getByText(/A renderizar mapa de Portugal/i)).toBeInTheDocument();
  });
  
  it('renders zoom controls', async () => {
    render(<PixelGrid />);
    await waitFor(() => {
      const zoomInButton = screen.getByLabelText('Zoom In');
      const zoomOutButton = screen.getByLabelText('Zoom Out');
      expect(zoomInButton).toBeInTheDocument();
      expect(zoomOutButton).toBeInTheDocument();
    });
  });
  
  it('handles zoom in button click', async () => {
    render(<PixelGrid />);
    await waitFor(() => {
      const zoomInButton = screen.getByLabelText('Zoom In');
      fireEvent.click(zoomInButton);
      // Would need to check if zoom state changed, but that's internal
      // This is just checking if the click handler doesn't throw
      expect(zoomInButton).toBeInTheDocument();
    });
  });
  
  it('handles zoom out button click', async () => {
    render(<PixelGrid />);
    await waitFor(() => {
      const zoomOutButton = screen.getByLabelText('Zoom Out');
      fireEvent.click(zoomOutButton);
      expect(zoomOutButton).toBeInTheDocument();
    });
  });
  
  it('handles reset view button click', async () => {
    render(<PixelGrid />);
    await waitFor(() => {
      const resetButton = screen.getByLabelText('Reset View');
      fireEvent.click(resetButton);
      expect(resetButton).toBeInTheDocument();
    });
  });
  
  // More tests would be added for:
  // - Pixel selection
  // - Map navigation
  // - Pixel purchase
  // - AI description generation
  // - Performance mode toggling
});
